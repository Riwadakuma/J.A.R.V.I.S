 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/tools_cli/jarvis_cli.py b/tools_cli/jarvis_cli.py
index 302dabbd5cec93274f4c35f212b1a4e820bf6e8f..ffe85459680a59ac17527359b392a5a933871f17 100644
--- a/tools_cli/jarvis_cli.py
+++ b/tools_cli/jarvis_cli.py
@@ -4,64 +4,68 @@ import logging
 from pathlib import Path
 from typing import Dict, Any, Tuple, Optional
 import requests, yaml
 
 DEFAULT_CFG = {
     "controller": {"base_url": "http://127.0.0.1:8010", "timeout_sec": 30},
     "toolrunner": {"base_url": "http://127.0.0.1:8011", "timeout_sec": 30, "shared_token": ""},
     "ui": {
         "mode": "pretty",                     # pretty | json | raw
         "history_file": "../data/cli_history.txt",
         "log_file": "../logs/cli.log",
         "spinner": True,
         "confirm_on_low_conf": False,
         "auto_exec": True,
     },
 }
 
 ENV_OVERRIDES = {
     "controller.base_url": "JARVIS_CONTROLLER_URL",
     "toolrunner.base_url": "JARVIS_TOOLRUNNER_URL",
     "toolrunner.shared_token": "JARVIS_TOOLRUNNER_TOKEN",
 }
 
 # ---------- config & io ----------
 
-def load_cfg() -> Dict[str, Any]:
-    """Load configuration, applying defaults and environment overrides.
-
-    Returns:
-        Combined configuration dictionary.
-    """
+def load_cfg(path: Optional[str] = None) -> Dict[str, Any]:
+    """Load configuration, applying defaults and environment overrides.
+
+    Args:
+        path: Optional path to configuration file. If ``None``, use the
+            ``cli_config.yaml`` located next to this script.
+
+    Returns:
+        Combined configuration dictionary.
+    """
     here = Path(__file__).parent
-    cfg_path = here / "cli_config.yaml"
+    cfg_path = Path(path).expanduser() if path else here / "cli_config.yaml"
     data: Dict[str, Any] = {}
     if cfg_path.exists():
         try:
             data = yaml.safe_load(cfg_path.read_text(encoding="utf-8")) or {}
         except Exception:
-            logging.exception(f"Failed to load config from {cfg_path}")
+            logging.exception(f"Failed to load config from {cfg_path}")
             data = {}
     cfg = deep_merge(DEFAULT_CFG, data)
     # env overrides
     for key, env in ENV_OVERRIDES.items():
         val = os.getenv(env)
         if val:
             set_deep(cfg, key, val)
     return cfg
 
 
 def deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
     """Recursively merge mapping ``b`` into ``a`` and return the result."""
     out = dict(a)
     for k, v in (b or {}).items():
         if isinstance(v, dict) and isinstance(out.get(k), dict):
             out[k] = deep_merge(out[k], v)
         else:
             out[k] = v
     return out
 
 
 def set_deep(d: Dict[str, Any], dotted: str, value: Any):
     """Set a nested ``value`` in ``d`` using dotted path notation."""
     node = d
     parts = dotted.split(".")
diff --git a/tools_cli/jarvis_cli.py b/tools_cli/jarvis_cli.py
index 302dabbd5cec93274f4c35f212b1a4e820bf6e8f..ffe85459680a59ac17527359b392a5a933871f17 100644
--- a/tools_cli/jarvis_cli.py
+++ b/tools_cli/jarvis_cli.py
@@ -399,53 +403,54 @@ def repl(cfg: Dict[str, Any], mode: str, no_exec: bool, verbose: int):
             if line == "/pretty":
                 mode = "pretty"; print("mode=pretty"); continue
             if line == "/raw":
                 mode = "raw"; print("mode=raw"); continue
             code = run_once(cfg, line, mode, no_exec=no_exec, verbose=verbose)
             if code != 0:
                 # не валим REPL из-за ошибки команды
                 pass
         except KeyboardInterrupt:
             print()
             break
 
 # ---------- main ----------
 
 
 def main():
     """Parse CLI arguments and run the requested mode."""
     p = argparse.ArgumentParser(prog="jarvis", description="CLI клиент для локального JARVIS")
     g = p.add_mutually_exclusive_group()
     g.add_argument("-e", "--execute", dest="text", help="Одноразовый запуск: отправить строку в /chat (и /execute при команде)")
     g.add_argument("-f", "--file", dest="file", help="Прочитать файл и отправить содержимое")
     p.add_argument("--json", action="store_true", help="Вывод JSON")
     p.add_argument("--raw", action="store_true", help="Сырой вывод без форматирования")
     p.add_argument("--no-exec", action="store_true", help="Не выполнять команды (dry-run, только показать)")
     p.add_argument("-v", "--verbose", action="count", default=0, help="Подробности (повтор для ещё больше)")
+    p.add_argument("--config", dest="config", help="Путь к YAML конфигурации")
     args = p.parse_args()
 
-    cfg = load_cfg()
+    cfg = load_cfg(args.config)
     mode = (cfg.get("ui") or {}).get("mode", "pretty")
     if args.json:
         mode = "json"
     if args.raw:
         mode = "raw"
 
     # чтение из файла
     if args.file:
         pth = Path(args.file)
         if not pth.exists():
             print("E_FILE_NOT_FOUND", file=sys.stderr)
             sys.exit(1)
         text = pth.read_text(encoding="utf-8", errors="ignore")
         sys.exit(run_once(cfg, text, mode, no_exec=args.no_exec, verbose=args.verbose))
 
     # одноразовый запуск
     if args.text is not None:
         sys.exit(run_once(cfg, args.text, mode, no_exec=args.no_exec, verbose=args.verbose))
 
     # если на вход подали stdin (pipeline)
     if not sys.stdin.isatty():
         text = sys.stdin.read()
         sys.exit(run_once(cfg, text, mode, no_exec=args.no_exec, verbose=args.verbose))
 
     # REPL
 
EOF
)